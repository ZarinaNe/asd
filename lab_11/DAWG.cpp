//
// Created by пк1 on 19.07.2023.
//

#include "DAWG.hpp"

DAWG::DAWG(std::string s) {
    _s = s;
    // Добалвяем начальное состояние в автомат
    _st[0].len = 0;
    _st[0].link = -1;
    _sz++;
}

void DAWG::DAWG_extend(char c) {
    int cur = _sz++; // Создаем новое состояние
    _st[cur].len = _st[_last].len + 1;
    int p; // номер состояния на котором, мы обнаружим, что переход по символу с имеется
    /* Описание цикла:
     1.изначально мы стоим в состоянии last;
     2.если из него нет перехода по букве c, то добавляем этот переход по букве c в состояние cur,
     3.затем переходим по суффиксной ссылке, снова проверяя — если нет перехода, то добавляем
     4.Если в какой-то момент случится, что такой переход уже есть, то останавливаемся — и обозначим через p номер состояния, на котором это произошло.
     */
    for (p=_last; p!=-1 && !_st[p].next.count(c); p=_st[p].link) {
        _st[p].next[c] = cur;
    }
    if (p == -1) {//  Ни разу не случилось, что имелся переход по букве с. Тогда суффиксная ссылка из этого состояния = 0;
        _st[cur].link = 0;
        // Иначе: мы остановились на каком-то сотоянии, из которого уже был переход по букве с.
    } else {
        int q = _st[p].next[c]; // q - куда ведет имеющийся переход по букве с
        if (_st[p].len + 1 == _st[q].len) {// Если состояние сплошное, то
            _st[cur].link = q; // ссылка текущего элемента = q
            /*Если состояние не является сплошным - необходимо произвести "клонирование" состояния q:
              создать новое состояние clone,копировав в него все данные из вершины q (суффиксную ссылку, переходы)
              len надо присвоить len(clone) = len(p) + 1.
             */
        }else {
            int clone = _sz++;
            _st[clone].len = _st[p].len + 1;
            _st[clone].next = _st[q].next;
            _st[clone].link = _st[q].link;
            for (; p!=-1 && _st[p].next[c]==q; p=_st[p].link)
                _st[p].next[c] = clone;
            _st[q].link = clone; // Cуффиксная ссылка q проводится в clone
            _st[cur].link = clone;//После клонирования мы проводим суффиксную ссылку из cur в это состояние clone
        }
    }
    _last = cur; //В любом случае, чем бы ни закончилось выполнение этой процедуры, мы в конце обновляем значение last, присваивая ему cur.
}

void DAWG::getDAWG() {
    for (int i=0; i < _s.length(); ++i) {
        DAWG_extend (_s[i]);
    }
}

bool DAWG::DAWG_search(std::string t) {
    if(t.length()>_s.length()) {
        std::cout << "Строка t не может являтся подстрокой s" << std::endl;
        return false;
    }
    getDAWG(); // Построение суффиксного автомата
    int v = 0; // v - текущее состояние, изначально она равна начальному состоянию t_0
    for (int i = 0; i < t.length(); ++i) { // Идем по символам подстроки t
        if (_st[v].next.count(t[i])) { // Делаем, если возможно переход из текущего состояния v в новое состояние
            v = _st[v].next[t[i]];
        } else {// Если перехода нет из текущего, то подстрока не входит в t;
            std::cout << "Строка t не является подстрокой s"<< std::endl;
            return false;
        }
    }
    std::cout << "Строка t  является подстрокой s"<< std::endl;
    return true;
}
